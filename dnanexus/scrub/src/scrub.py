#!/usr/bin/env python
# scrub 0.0.1
# Generated by dx-app-wizard.
#

from __future__ import print_function
import os
import sys
import dxpy
import common
import subprocess
import shlex
import logging
from multiprocessing import Pool

logger = logging.getLogger(__name__)
logger.addHandler(dxpy.DXLogHandler())
logger.propagate = False
logger.setLevel(logging.INFO)


def shell_command(command_string):
    logger.info(command_string)
    try:
        return subprocess.check_output(shlex.split(command_string))
    except subprocess.CalledProcessError as e:
        logger.error(
            "%s exited with return code %s" % (command_string, e.returncode))
        logger.error(e.output)
        return None
    except:
        raise


def scrub(in_filepath, out_filepath):
    # Check the input.
    logger.debug("Input flagstat for %s" % (in_filepath))
    logger.debug(shell_command("samtools flagstat %s" % (in_filepath)))
    # Set up the paths to inputs and outputs.
    dirname = os.path.dirname(out_filepath)
    header_path = os.path.join(dirname, "header.txt")
    sam_path = os.path.join(dirname, "scrubbed.sam")
    # Cache the header.
    shell_command("samtools view -H %s -o %s" % (in_filepath, header_path))
    # Scrub the sequence from field 10 with awk.
    common.run_pipe([
        'samtools view %s' % (in_filepath),
        r"""awk '{OFS="\t"} {s=""; for(i=1;i<=length($10);i++) s=(s "N"); $10=s; $11="*"; print}'"""
        ], sam_path)
    # Add back the header.
    common.run_pipe([
        'cat %s %s' % (header_path, sam_path),
        'samtools view -S -b - -o %s' % (out_filepath)])
    # Check the output.
    logger.debug("Output flagstat for %s" % (out_filepath))
    logger.debug(shell_command("samtools flagstat %s" % (out_filepath)))


@dxpy.entry_point('main')
def main(input_bams):

    # Initialize data object inputs on the platform
    # into dxpy.DXDataObject instances.

    input_bams = [dxpy.DXFile(item) for item in input_bams]

    # Download each file input to a new directory in the the local file system
    # using variable names for the filenames.
    # Construct output filenames.
    # Dispatch jobs to a pool of workers.

    out_paths = []
    pool = Pool()  # default is pool of cpu_count() workers

    for i, bam in enumerate(input_bams):
        dirname = str(i)
        filename = bam.name
        os.mkdir(dirname)
        in_path = os.path.join(dirname, filename)
        dxpy.download_dxfile(bam.get_id(), in_path)
        out_path = os.path.join(dirname, "scrub-" + filename)
        out_paths.append(out_path)
        pool.apply_async(scrub, (in_path, out_path))

    # Close the worker pool and block until all jobs are complete.
    pool.close()
    pool.join()

    # Populate output fields and return.
    output_bams = [dxpy.upload_local_file(path) for path in out_paths]
    output = {
        "output_bams": [dxpy.dxlink(output_bam) for output_bam in output_bams]
    }
    return output


dxpy.run()
